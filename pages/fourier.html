<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourier Transform Visualization</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            padding: 10px;
            border-radius: 5px;
        }

        .controls label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .controls label math {
            font-size: 16px;
            vertical-align: middle;
        }

        .controls input[type="number"] {
            width: 60px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 3px 5px;
            border-radius: 3px;
            margin-left: 10px;
        }

        .controls .slider-container {
            margin-bottom: 15px;
        }

        .controls input[type="range"] {
            width: 300px;
            display: block;
            margin-top: 5px;
        }

        .equation {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .equation math {
            font-size: 20px;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="equation">
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mrow>
                <mi>g</mi>
                <mo>(</mo>
                <mi>t</mi>
                <mo>)</mo>
                <mo>=</mo>
                <msub>
                    <mi>A</mi>
                    <mn>1</mn>
                </msub>
                <mo>cos</mo>
                <mo>(</mo>
                <mn>2</mn>
                <mi>π</mi>
                <msub>
                    <mi>f</mi>
                    <mn>1</mn>
                </msub>
                <mi>t</mi>
                <mo>+</mo>
                <msub>
                    <mi>φ</mi>
                    <mn>1</mn>
                </msub>
                <mo>)</mo>
                <mo>+</mo>
                <msub>
                    <mi>A</mi>
                    <mn>2</mn>
                </msub>
                <mo>cos</mo>
                <mo>(</mo>
                <mn>2</mn>
                <mi>π</mi>
                <msub>
                    <mi>f</mi>
                    <mn>2</mn>
                </msub>
                <mi>t</mi>
                <mo>+</mo>
                <msub>
                    <mi>φ</mi>
                    <mn>2</mn>
                </msub>
                <mo>)</mo>
            </mrow>
        </math>
        <br>
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mstyle displaystyle="true">
                <mrow>
                    <mover>
                        <mi>g</mi>
                        <mo>^</mo>
                    </mover>
                    <mrow>
                        <mo stretchy="false">(</mo>
                        <mi>f</mi>
                        <mo stretchy="false">)</mo>
                    </mrow>
                    <mo>=</mo>
                    <munderover>
                        <mo>∫</mo>
                        <mrow>
                            <mo>-</mo>
                            <mi>∞</mi>
                        </mrow>
                        <mrow>
                            <mo>+</mo>
                            <mi>∞</mi>
                        </mrow>
                    </munderover>
                    <mi>g</mi>
                    <mrow>
                        <mo stretchy="false">(</mo>
                        <mi>t</mi>
                        <mo stretchy="false">)</mo>
                    </mrow>
                    <msup>
                        <mi>e</mi>
                        <mrow>
                            <mo>-</mo>
                            <mn>2</mn>
                            <mi>π</mi>
                            <mi>i</mi>
                            <mi>f</mi>
                            <mi>t</mi>
                        </mrow>
                    </msup>
                    <mi>d</mi>
                    <mi>t</mi>
                </mrow>
            </mstyle>
        </math>
    </div>
    <div class="controls">
        <label for="A1">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>A</mi>
                    <mn>1</mn>
                </msub>
            </math>:
            <input type="number" id="A1_input" min="0" max="0.5" step="0.01" value="0.4">
        </label>
        <div class="slider-container">
            <input type="range" id="A1" min="0" max="0.5" step="0.01" value="0.4">
        </div>

        <label for="f1">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>f</mi>
                    <mn>1</mn>
                </msub>
            </math>:
            <input type="number" id="f1_input" min="0" max="5" step="0.1" value="3">
        </label>
        <div class="slider-container">
            <input type="range" id="f1" min="0" max="5" step="0.1" value="3">
        </div>

        <label for="phase1">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>φ</mi>
                    <mn>1</mn>
                </msub>
            </math>&nbsp;[°]:
            <input type="number" id="phase1_input" min="0" max="359" step="1" value="90">
        </label>
        <div class="slider-container">
            <input type="range" id="phase1" min="0" max="359" step="1" value="90">
        </div>

        <label for="A2">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>A</mi>
                    <mn>2</mn>
                </msub>
            </math>:
            <input type="number" id="A2_input" min="0" max="0.5" step="0.01" value="0.4">
        </label>
        <div class="slider-container">
            <input type="range" id="A2" min="0" max="0.5" step="0.01" value="0.4">
        </div>

        <label for="f2">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>f</mi>
                    <mn>2</mn>
                </msub>
            </math>:
            <input type="number" id="f2_input" min="0" max="5" step="0.1" value="2">
        </label>
        <div class="slider-container">
            <input type="range" id="f2" min="0" max="5" step="0.1" value="2">
        </div>

        <label for="phase2">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <msub>
                    <mi>φ</mi>
                    <mn>2</mn>
                </msub>
            </math>&nbsp;[°]:
            <input type="number" id="phase2_input" min="0" max="359" step="1" value="0">
        </label>
        <div class="slider-container">
            <input type="range" id="phase2" min="0" max="359" step="1" value="0">
        </div>

        <label for="winding_f">
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
                <mtext>winding</mtext>
                <mo>&#x2009;</mo>
                <mi>f</mi>
            </math>:
            <input type="number" id="winding_f_input" min="0" max="5" step="0.1" value="2">
        </label>
        <div class="slider-container">
            <input type="range" id="winding_f" min="0" max="5" step="0.1" value="2">
        </div>
    </div>

    <script>
        var Module = {
            // Configuration options
            onRuntimeInitialized: function () {
                console.log("WebAssembly module is ready!");
                // Call your functions that use the module here
            }
        }

        function performFFT(inputData) {
            try {
                // Size of the data (must be a power of 2)
                const size = inputData.length;

                // Allocate memory in the WASM module
                if (typeof Module._malloc !== 'function') {
                    console.error("Module._malloc is not available. Available exports:", Object.keys(Module));
                    throw new Error("malloc function not available");
                }

                const inputPtr = Module._malloc(size * 4); // 4 bytes per float
                const outputPtr = Module._malloc(size * 8); // 8 bytes per complex (real+imaginary)

                // Copy input data to WASM memory
                const inputHeap = new Float32Array(Module.HEAPF32.buffer, inputPtr, size);
                inputHeap.set(inputData);

                // Create FFT config for real-to-complex transform
                if (typeof Module._kiss_fftr_alloc !== 'function') {
                    console.error("Module._kiss_fftr_alloc is not available");
                    throw new Error("kiss_fftr_alloc function not available");
                }

                const fftConfig = Module._kiss_fftr_alloc(size, 0, 0, 0);

                // Run the FFT
                Module._kiss_fftr(fftConfig, inputPtr, outputPtr);

                // Get the result
                const outputHeap = new Float32Array(Module.HEAPF32.buffer, outputPtr, size * 2);

                // Create a copy of the data
                const result = new Float32Array(size * 2);
                for (let i = 0; i < size * 2; i++) {
                    result[i] = outputHeap[i];
                }

                // Clean up
                Module._free(inputPtr);
                Module._free(outputPtr);
                Module._free(fftConfig);

                return result;
            } catch (error) {
                console.error("Error in performFFT:", error);
                throw error;
            }
        }

        function main() {
            // Get canvas element
            const canvas = document.getElementById('canvas');

            // Get WebGL context
            let gl = null;
            try {
                gl = canvas.getContext('webgl');
                if (!gl) gl = canvas.getContext('experimental-webgl');
            } catch (e) {
                console.error("Error initializing WebGL:", e);
                document.body.innerHTML = "<p style='color:white;padding:20px;'>Error initializing WebGL: " + e.message + "</p>";
                return;
            }

            if (!gl) {
                document.body.innerHTML = "<p style='color:white;padding:20px;'>WebGL not supported in this browser</p>";
                return;
            }

            // Set canvas size
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            // Add resize event listener
            window.addEventListener('resize', resize);
            resize();

            viridis_def = `
                vec4 viridis(float x) {
                    // Convert to HSL space with constant luminance
                    float hue = mix(0.7, 0.0, clamp(x, 0.0, 1.0)); // From blue to red (in normalized HSL)
                    const float saturation = 0.85;
                    const float luminance = 0.65;  // Constant luminance value
                    
                    // HSL to RGB conversion
                    float chroma = (1.0 - abs(2.0 * luminance - 1.0)) * saturation;
                    float huePrime = hue * 6.0;
                    float x1 = chroma * (1.0 - abs(mod(huePrime, 2.0) - 1.0));
                    
                    vec3 rgb;
                    if (huePrime < 1.0) rgb = vec3(chroma, x1, 0.0);
                    else if (huePrime < 2.0) rgb = vec3(x1, chroma, 0.0);
                    else if (huePrime < 3.0) rgb = vec3(0.0, chroma, x1);
                    else if (huePrime < 4.0) rgb = vec3(0.0, x1, chroma);
                    else if (huePrime < 5.0) rgb = vec3(x1, 0.0, chroma);
                    else rgb = vec3(chroma, 0.0, x1);
                    
                    float lightnessAdjustment = luminance - chroma / 2.0;
                    rgb += vec3(lightnessAdjustment);
                    
                    return vec4(rgb, 1.0);
                }
            `;

            // JavaScript function to calculate wave y values
            function calculateWave(x, A1, f1, phase1, A2, f2, phase2) {
                const PI = Math.PI;
                return A1 * Math.cos(x * 2 * PI * f1 + phase1 * PI / 180) +
                    A2 * Math.cos(x * 2 * PI * f2 + phase2 * PI / 180);
            }

            // Define calc_y for the winding shader
            const calc_y = `u_A1*cos(x*2.*PI*u_f1 + u_phase1*PI/180.) + u_A2*cos(x*2.*PI*u_f2 + u_phase2*PI/180.)`;

            // Draw winding diagram
            const vs_winding = `
                #define PI 3.14159265

                attribute float aXPosition;
                uniform float u_aspect;
                varying vec4 v_color;
                        
                uniform float u_A1;
                uniform float u_f1;
                uniform float u_A2;
                uniform float u_f2;
                uniform float u_phase1;
                uniform float u_phase2;
                uniform float u_winding_f;

                ${viridis_def}
                
                void main() {
                    float x = aXPosition;
                    float y = ${calc_y};

                    // wind (TODO fix N & k)
                    float N = 8192.;
                    float k = x*N;
                    float j = u_winding_f;
                    float a = (k*j)*atan(-sin(2.*PI/N), cos(2.*PI/N));
                    float w_real = y*cos(a);
                    float w_imag = y*sin(a);

                    float screen_x = w_real;
                    float screen_y = w_imag;

                    screen_y = w_imag - 0.65;

                    screen_x = 0.6*screen_x;
                    screen_y = 0.6*screen_y;

                    gl_Position = vec4(screen_x/u_aspect - 0.5, screen_y, 0.0, 1.0);

                    v_color = viridis(x/20.);
                }
            `;

            // Line shader with optional viridis coloring
            const vs_line = `
                attribute vec2 a_xy;
                varying vec4 v_color;
                uniform vec4 u_color;
                uniform int u_use_viridis;
                
                ${viridis_def}
                
                void main() {
                    gl_Position = vec4(a_xy, 0.0, 1.0);
                    
                    if (u_use_viridis == 1) {
                        // Use x coordinate for viridis coloring (normalized to 0-1)
                        float x = (a_xy.x + 1.0) * 0.5; // Convert from [-1,1] to [0,1]
                        // x is now in [0,1] for coloring purposes
                        v_color = viridis(x);
                    } else {
                        v_color = u_color;
                    }
                }
            `;

            // Create shader program
            function createShaderProgram(vsSource) {
                // Fragment shader source
                const fsSource = `
                    precision mediump float;

                    varying vec4 v_color;
                    
                    void main() {
                        gl_FragColor = v_color;
                    }
                `;

                // Create shaders
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vsSource);
                gl.compileShader(vertexShader);

                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    console.error("Vertex shader compilation failed:", gl.getShaderInfoLog(vertexShader));
                    return null;
                }

                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fsSource);
                gl.compileShader(fragmentShader);

                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    console.error("Fragment shader compilation failed:", gl.getShaderInfoLog(fragmentShader));
                    return null;
                }

                // Create program and attach shaders
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                // Check for errors
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    const error = gl.getProgramInfoLog(shaderProgram);
                    console.error("Failed to link program:", error);
                    return null;
                }

                return shaderProgram;
            }

            // Create programs
            const windingProgram = createShaderProgram(vs_winding);
            const lineProgram = createShaderProgram(vs_line);

            if (!windingProgram || !lineProgram) {
                document.body.innerHTML = "<p style='color:white;padding:20px;'>Failed to create shader program</p>";
                return;
            }

            locations = { winding: {}, line: {} };

            function init_program(shaderProgram, name) {
                // Use shader program
                gl.useProgram(shaderProgram);

                // Get attribute and uniform locations
                if (name == "winding") {
                    locations[name]["position"] = gl.getAttribLocation(shaderProgram, 'aXPosition');
                    locations[name]["A1"] = gl.getUniformLocation(shaderProgram, 'u_A1');
                    locations[name]["f1"] = gl.getUniformLocation(shaderProgram, 'u_f1');
                    locations[name]["A2"] = gl.getUniformLocation(shaderProgram, 'u_A2');
                    locations[name]["f2"] = gl.getUniformLocation(shaderProgram, 'u_f2');
                    locations[name]["phase1"] = gl.getUniformLocation(shaderProgram, 'u_phase1');
                    locations[name]["phase2"] = gl.getUniformLocation(shaderProgram, 'u_phase2');
                    locations[name]["winding_f"] = gl.getUniformLocation(shaderProgram, 'u_winding_f');
                    locations[name]["aspect"] = gl.getUniformLocation(shaderProgram, 'u_aspect');
                } else if (name == "line") {
                    locations[name]["xy"] = gl.getAttribLocation(shaderProgram, 'a_xy');
                    locations[name]["color"] = gl.getUniformLocation(shaderProgram, 'u_color');
                    locations[name]["use_viridis"] = gl.getUniformLocation(shaderProgram, 'u_use_viridis');
                }
            }

            init_program(windingProgram, "winding");
            init_program(lineProgram, "line");

            // Create position buffer for winding
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            const f_max = 20.;

            const NUM_POINTS = 8192;
            const positions = [];
            for (let i = 0; i < NUM_POINTS; i++) {
                const x = f_max * i / NUM_POINTS;
                positions.push(x);
            }

            // Fill buffer with positions
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // Create a buffer for line vertices
            const lineBuffer = gl.createBuffer();

            // Create buffers
            const waveBuffer = gl.createBuffer();
            const fftRealBuffer = gl.createBuffer();
            const fftImagBuffer = gl.createBuffer();
            const axisBuffer = gl.createBuffer();

            // Function to generate wave vertices
            function generateWaveVertices() {
                const vertices = [];
                const yValues = []; // Store y values for FFT

                for (let i = 0; i < NUM_POINTS; i++) {
                    const x = f_max * i / NUM_POINTS;
                    // Calculate y value using our JavaScript function
                    const y = calculateWave(x, A1, f1, phase1, A2, f2, phase2);
                    yValues.push(y); // Store for FFT

                    // Transform to screen coordinates
                    const screen_x = 2 * (i / NUM_POINTS) - 1; // Normalize to [-1,1] for display
                    let screen_y = 0.5 * y + 0.5; // [-1,1] -> [0,1]
                    screen_y = 0.7 * screen_y + 0.3;
                    screen_y = screen_y * 0.95 - 0.025; // pad

                    vertices.push(screen_x, screen_y);
                }

                return {
                    vertices: new Float32Array(vertices),
                    yValues: new Float32Array(yValues)
                };
            }

            // Function to generate FFT vertices
            function generateFFTVertices(yValues) {
                try {
                    // Perform FFT on the y values
                    const fftResult = performFFT(yValues);

                    // Create vertices for real part
                    const realVertices = [];
                    // Create vertices for imaginary part
                    const imagVertices = [];

                    NUM_FREQS = 5 * f_max + 3;

                    // Neg freq components
                    for (let i = NUM_FREQS - 1; i >= 0; i--) {
                        let x = (NUM_FREQS - i) / (2 * NUM_FREQS);

                        // Get real and imaginary parts
                        const real = fftResult[i * 2];
                        const imag = -fftResult[i * 2 + 1];

                        // Normalize magnitude for display
                        const normalizedReal = real / (NUM_POINTS / 2);
                        const normalizedImag = imag / (NUM_POINTS / 2);

                        // Transform to screen coordinates
                        const screen_x = x;

                        // Position real part in top half
                        const screen_y_real = 0.3 * normalizedReal - 0.2;

                        // Position imaginary part in bottom half
                        const screen_y_imag = 0.3 * normalizedImag - 0.6;

                        realVertices.push(screen_x, screen_y_real);
                        imagVertices.push(screen_x, screen_y_imag);
                    }

                    // Pos freq components
                    for (let i = 0; i < NUM_FREQS; i++) {
                        let x = (i + NUM_FREQS) / (2 * NUM_FREQS);

                        // Get real and imaginary parts
                        const real = fftResult[i * 2];
                        const imag = fftResult[i * 2 + 1];

                        // Normalize magnitude for display
                        const normalizedReal = real / (NUM_POINTS / 2);
                        const normalizedImag = imag / (NUM_POINTS / 2);

                        // Transform to screen coordinates
                        const screen_x = x;

                        // Position real part in top half
                        const screen_y_real = 0.3 * normalizedReal - 0.2;

                        // Position imaginary part in bottom half
                        const screen_y_imag = 0.3 * normalizedImag - 0.6;

                        realVertices.push(screen_x, screen_y_real);
                        imagVertices.push(screen_x, screen_y_imag);
                    }

                    return {
                        real: new Float32Array(realVertices),
                        imag: new Float32Array(imagVertices)
                    };
                } catch (error) {
                    console.error("Error generating FFT vertices:", error);
                    // Return empty arrays if FFT fails
                    return {
                        real: new Float32Array([]),
                        imag: new Float32Array([])
                    };
                }
            }

            // UI controls
            const A1_slider = document.getElementById('A1');
            const f1_slider = document.getElementById('f1');
            const A1_input = document.getElementById('A1_input');
            const f1_input = document.getElementById('f1_input');
            const A2_slider = document.getElementById('A2');
            const f2_slider = document.getElementById('f2');
            const A2_input = document.getElementById('A2_input');
            const f2_input = document.getElementById('f2_input');
            const phase1_slider = document.getElementById('phase1');
            const phase2_slider = document.getElementById('phase2');
            const phase1_input = document.getElementById('phase1_input');
            const phase2_input = document.getElementById('phase2_input');
            const winding_f_slider = document.getElementById('winding_f');
            const winding_f_input = document.getElementById('winding_f_input');

            let A1 = parseFloat(A1_slider.value);
            let f1 = parseFloat(f1_slider.value);
            let A2 = parseFloat(A2_slider.value);
            let f2 = parseFloat(f2_slider.value);
            let phase1 = parseFloat(phase1_slider.value);
            let phase2 = parseFloat(phase2_slider.value);
            let winding_f = parseFloat(winding_f_slider.value);

            // Function to update values from sliders
            function updateFromSlider(slider, input, value, precision = 2) {
                value = parseFloat(slider.value);
                input.value = value.toFixed(precision);
                return value;
            }

            // Function to update values from text inputs
            function updateFromInput(input, slider, min, max, currentValue) {
                // Only process if the value is a valid number                                                                                                                             
                if (!isNaN(parseFloat(input.value))) {
                    let newValue = parseFloat(input.value);
                    // Clamp value to min/max range                                                                                                                                        
                    newValue = Math.max(min, Math.min(max, newValue));

                    // Only update if it's different from the current value                                                                                                                
                    if (newValue !== currentValue) {
                        slider.value = newValue;
                        return newValue;
                    }
                }
                // Return the current value if no valid update                                                                                                                             
                return currentValue;
            }

            // Add event listeners for sliders
            A1_slider.addEventListener('input', function () {
                A1 = updateFromSlider(this, A1_input, A1);
            });
            f1_slider.addEventListener('input', function () {
                f1 = updateFromSlider(this, f1_input, f1);
            });
            A2_slider.addEventListener('input', function () {
                A2 = updateFromSlider(this, A2_input, A2);
            });
            f2_slider.addEventListener('input', function () {
                f2 = updateFromSlider(this, f2_input, f2);
            });
            phase1_slider.addEventListener('input', function () {
                phase1 = updateFromSlider(this, phase1_input, phase1, 0);
            });
            phase2_slider.addEventListener('input', function () {
                phase2 = updateFromSlider(this, phase2_input, phase2, 0);
            });
            winding_f_slider.addEventListener('input', function () {
                winding_f = updateFromSlider(this, winding_f_input, winding_f);
            });

            // Add event listeners for text inputs - using input event for immediate updates
            A1_input.addEventListener('input', function () {
                A1 = updateFromInput(this, A1_slider, 0, 0.5, A1);
            });
            f1_input.addEventListener('input', function () {
                f1 = updateFromInput(this, f1_slider, 0, 5, f1);
            });
            A2_input.addEventListener('input', function () {
                A2 = updateFromInput(this, A2_slider, 0, 0.5, A2);
            });
            f2_input.addEventListener('input', function () {
                f2 = updateFromInput(this, f2_slider, 0, 5, f2);
            });
            phase1_input.addEventListener('input', function () {
                phase1 = updateFromInput(this, phase1_slider, 0, 359, phase1);
            });
            phase2_input.addEventListener('input', function () {
                phase2 = updateFromInput(this, phase2_slider, 0, 359, phase2);
            });
            winding_f_input.addEventListener('input', function () {
                winding_f = updateFromInput(this, winding_f_slider, 0, 5, winding_f);
            });

            const axisVertices = new Float32Array([0.5, 0, 0.5, -0.8]);

            // Draw function
            function draw(time) {
                // Clear canvas
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Generate wave vertices based on current parameters
                const waveData = generateWaveVertices();

                // Draw wave using line shader with viridis coloring
                gl.useProgram(lineProgram);
                gl.uniform4f(locations["line"]["color"], 0.0, 0.8, 1.0, 1.0); // Fallback color
                gl.uniform1i(locations["line"]["use_viridis"], 1); // Enable viridis coloring
                gl.bindBuffer(gl.ARRAY_BUFFER, waveBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, waveData.vertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations["line"]["xy"]);
                gl.vertexAttribPointer(locations["line"]["xy"], 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINE_STRIP, 0, NUM_POINTS);

                // Draw y axis for FFT
                gl.useProgram(lineProgram);
                gl.uniform4f(locations["line"]["color"], 1., 1., 1., 1.0); // White
                gl.uniform1i(locations["line"]["use_viridis"], 0); // Disable viridis coloring
                gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, axisVertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations["line"]["xy"]);
                gl.vertexAttribPointer(locations["line"]["xy"], 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINE_STRIP, 0, axisVertices.length / 2);

                // Generate FFT vertices
                const fftVertices = generateFFTVertices(waveData.yValues);

                // Draw FFT real part
                gl.useProgram(lineProgram);
                gl.uniform4f(locations["line"]["color"], 1.0, 0.5, 0.5, 1.0); // Light red
                gl.uniform1i(locations["line"]["use_viridis"], 0); // Disable viridis coloring
                gl.bindBuffer(gl.ARRAY_BUFFER, fftRealBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, fftVertices.real, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations["line"]["xy"]);
                gl.vertexAttribPointer(locations["line"]["xy"], 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINE_STRIP, 0, fftVertices.real.length / 2);

                // Draw FFT imaginary part
                gl.useProgram(lineProgram);
                gl.uniform4f(locations["line"]["color"], 0.5, 0.5, 1., 1.0); // Light blue
                gl.uniform1i(locations["line"]["use_viridis"], 0); // Disable viridis coloring
                gl.bindBuffer(gl.ARRAY_BUFFER, fftImagBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, fftVertices.imag, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(locations["line"]["xy"]);
                gl.vertexAttribPointer(locations["line"]["xy"], 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINE_STRIP, 0, fftVertices.imag.length / 2);

                // Draw winding
                gl.useProgram(windingProgram);
                // Update uniforms
                gl.uniform1f(locations["winding"]["A1"], A1);
                gl.uniform1f(locations["winding"]["f1"], f1);
                gl.uniform1f(locations["winding"]["A2"], A2);
                gl.uniform1f(locations["winding"]["f2"], f2);
                gl.uniform1f(locations["winding"]["phase1"], phase1);
                gl.uniform1f(locations["winding"]["phase2"], phase2);
                gl.uniform1f(locations["winding"]["winding_f"], winding_f);
                gl.uniform1f(locations["winding"]["aspect"], canvas.width / canvas.height);

                // Set up position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(locations["winding"]["position"]);
                gl.vertexAttribPointer(locations["winding"]["position"], 1, gl.FLOAT, false, 0, 0);

                // Draw line strip (connected line segments for smooth curve)
                gl.drawArrays(gl.LINE_STRIP, 0, NUM_POINTS);

                // Request next frame
                requestAnimationFrame(draw);
            }

            // Start animation loop
            requestAnimationFrame(draw);
        }
        main();
    </script>

    <script src="kissfft.js"></script>
</body>

</html>